export = Utils;
declare function Utils(log_in: any): void;
declare class Utils {
    constructor(log_in: any);
    log: any;
    ak: string | null;
    sk: string | null;
    securityToken: string | null;
    isSecure: boolean;
    server: any;
    pathStyle: boolean;
    signatureContext: {
        signature: string;
        headerPrefix: string;
        headerMetaPrefix: string;
        authPrefix: string;
    } | null;
    isSignatureNegotiation: boolean;
    bucketSignatureCache: {};
    region: string;
    port: number | null;
    timeout: number;
    obsSdkVersion: string;
    isCname: boolean;
    bucketEventEmitters: {};
    useRawXhr: boolean;
    encodeURIWithSafe: typeof encodeURIWithSafe;
    mimeTypes: {
        '7z': string;
        aac: string;
        ai: string;
        aif: string;
        asc: string;
        asf: string;
        atom: string;
        avi: string;
        bmp: string;
        bz2: string;
        cer: string;
        crl: string;
        crt: string;
        css: string;
        csv: string;
        cu: string;
        deb: string;
        doc: string;
        docx: string;
        dvi: string;
        eot: string;
        eps: string;
        epub: string;
        etx: string;
        flac: string;
        flv: string;
        gif: string;
        gz: string;
        htm: string;
        html: string;
        ico: string;
        ics: string;
        ini: string;
        iso: string;
        jar: string;
        jpe: string;
        jpeg: string;
        jpg: string;
        js: string;
        json: string;
        latex: string;
        log: string;
        m4a: string;
        m4v: string;
        mid: string;
        midi: string;
        mov: string;
        mp3: string;
        mp4: string;
        mp4a: string;
        mp4v: string;
        mpe: string;
        mpeg: string;
        mpg: string;
        mpg4: string;
        oga: string;
        ogg: string;
        ogv: string;
        ogx: string;
        pbm: string;
        pdf: string;
        pgm: string;
        png: string;
        pnm: string;
        ppm: string;
        ppt: string;
        pptx: string;
        ps: string;
        qt: string;
        rar: string;
        ras: string;
        rss: string;
        rtf: string;
        sgm: string;
        sgml: string;
        svg: string;
        swf: string;
        tar: string;
        tif: string;
        tiff: string;
        torrent: string;
        ttf: string;
        txt: string;
        wav: string;
        webm: string;
        wma: string;
        wmv: string;
        woff: string;
        wsdl: string;
        xbm: string;
        xls: string;
        xlsx: string;
        xml: string;
        xpm: string;
        xwd: string;
        yaml: string;
        yml: string;
        zip: string;
    };
    refresh(ak: any, sk: any, securityToken: any): void;
    initFactory(ak: any, sk: any, isSecure: any, server: any, pathStyle: any, signature: any, region: any, port: any, timeout: any, securityToken: any, isSignatureNegotiation: any, isCname: any, urlPrefix: any, regionDomains: any, setRequestHeaderHook: any, useRawXhr: any): void;
    urlPrefix: any;
    regionDomains: any;
    setRequestHeaderHook: any;
    SseKmsAdapter(value: any, signatureContext: any): any;
    BucketAdapter(value: any, signatureContext: any): any;
    EventAdapter(value: any, signatureContext: any): any;
    URIAdapter(value: any, signatureContext: any): any;
    StorageClassAdapter(value: any, signatureContext: any): any;
    ACLAdapter(value: any, signatureContext: any): any;
    doExec(funcName: any, param: any, callback: any): any;
    doNegotiation(funcName: any, param: any, callback: any, checkBucket: any, checkCache: any, setCache: any): any;
    exec(funcName: any, param: any, callback: any): void;
    sliceBlob(blob: any, start: any, end: any, type: any): any;
    toXml(mXml: any, xmlMeta: any, root: any, sentAs: any, signatureContext: any): string;
    buildXml(mXml: any, xmlMeta: any, key: any, sentAs: any, signatureContext: any): string;
    jsonToObject(model: any, obj: any, root: any): {};
    buildObject(model: any, obj: any, key: any, opt: any): void;
    makeParam(methodName: any, param: any): {
        $requestParam: any;
        err: string;
        rawUri: string;
        requestUri: any;
        method: any;
        uri: any;
        urlPath: string;
        xml: string;
        headers: {
            'Content-Type': string;
            Host: any;
            'Content-MD5': any;
            'Content-Length': string;
        };
        PartSize: any;
        Offset: any;
    };
    parseCommonHeaders(opt: any, headers: any, signatureContext: any): void;
    contrustCommonMsg(opt: any, obj: any, headers: any, signatureContext: any): void;
    getRequest(methodName: any, serverback: any, signatureContext: any, retryCount: any, params: any, bc: any): any;
    makeRequest(methodName: any, opt: any, retryCount: any, bc: any): any;
    sendRequest(funcName: any, opt: any, backcall: any, retryCount: any): void;
    doAuth(opt: any, methodName: any, signatureContext: any): void;
    v4Auth(opt: any, methodName: any, signatureContext: any): void;
    bufMD5(buf: any): any;
    rawBufMD5(buf: any): any;
    createSignedUrlSync(param: any): {
        ActualSignedRequestHeaders: {};
        SignedUrl: string;
    };
    createV2SignedUrlSync(param: any): {
        ActualSignedRequestHeaders: {};
        SignedUrl: string;
    };
    createV4SignedUrlSync(param: any): {
        ActualSignedRequestHeaders: {
            Host: string;
        };
        SignedUrl: string;
    };
    createPostSignatureSync(param: any): {
        OriginPolicy: string;
        Policy: any;
        Algorithm: string;
        Credential: string;
        Date: string;
        Signature: any;
    } | {
        OriginPolicy: string;
        Policy: any;
        Signature: any;
        Token: string;
    };
    createV4PostSignatureSync(param: any): {
        OriginPolicy: string;
        Policy: any;
        Algorithm: string;
        Credential: string;
        Date: string;
        Signature: any;
    };
}
declare function encodeURIWithSafe(str: any, safe: any, skipEncoding: any): any;
